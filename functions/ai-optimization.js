// AI Optimization Worker - Autonomous Optimization System
// Analyzes user behavior data and generates optimization proposals

export default {
  async scheduled(event, env, ctx) {
    // This runs on a schedule (daily)
    await ctx.waitUntil(this.runAnalysis(env));
  },

  async fetch(request, env, ctx) {
    // Allow manual triggering via POST
    if (request.method === 'POST') {
      const auth = request.headers.get('Authorization');
      if (auth !== `Bearer ${env.API_SECRET}`) {
        return new Response('Unauthorized', { status: 401 });
      }

      await ctx.waitUntil(this.runAnalysis(env));
      return new Response(JSON.stringify({ success: true }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    return new Response('Method not allowed', { status: 405 });
  },

  async runAnalysis(env) {
    try {
      console.log('Starting AI optimization analysis...');

      // Initialize Supabase client
      const supabaseUrl = env.SUPABASE_URL;
      const supabaseKey = env.SUPABASE_SERVICE_ROLE_KEY;
      
      if (!supabaseUrl || !supabaseKey) {
        throw new Error('Missing Supabase configuration');
      }

      const { createClient } = await import('@supabase/supabase-js');
      const supabase = createClient(supabaseUrl, supabaseKey);

      // 1. Fetch recent friction points
      const { data: frictionPoints, error: frictionError } = await supabase
        .from('friction_points')
        .select('*')
        .order('event_count', { ascending: false })
        .limit(10);

      if (frictionError) {
        console.error('Error fetching friction points:', frictionError);
        throw frictionError;
      }

      if (!frictionPoints || frictionPoints.length === 0) {
        console.log('No friction points found for analysis');
        return;
      }

      // 2. Fetch component performance data
      const { data: componentPerformance, error: componentError } = await supabase
        .from('component_performance')
        .select('*')
        .order('rage_clicks', { ascending: false })
        .limit(20);

      if (componentError) {
        console.error('Error fetching component performance:', componentError);
        throw componentError;
      }

      // 3. Prepare data for AI analysis
      const analysisData = {
        friction_points: frictionPoints,
        component_performance: componentPerformance || [],
        analysis_timestamp: new Date().toISOString(),
        total_friction_events: frictionPoints.reduce((sum, fp) => sum + fp.event_count, 0)
      };

      // 4. Call AI service (OpenRouter)
      const aiResponse = await this.callAIService(env, analysisData);
      
      if (!aiResponse || !aiResponse.optimizations) {
        console.log('No optimizations generated by AI');
        return;
      }

      // 5. Process and validate AI proposals
      const validProposals = await this.validateProposals(aiResponse.optimizations, supabase);
      
      if (validProposals.length === 0) {
        console.log('No valid proposals after validation');
        return;
      }

      // 6. Create GitHub PR for each valid proposal
      const results = await Promise.allSettled(
        validProposals.map(proposal => this.createGitHubPR(env, proposal))
      );

      // 7. Record optimization history
      await this.recordOptimizationHistory(supabase, validProposals, results);

      console.log(`Analysis complete. Generated ${validProposals.length} proposals.`);

    } catch (error) {
      console.error('AI optimization analysis failed:', error);
      throw error;
    }
  },

  async callAIService(env, analysisData) {
    const openRouterApiKey = env.OPENROUTER_API_KEY;
    if (!openRouterApiKey) {
      throw new Error('OpenRouter API key not configured');
    }

    const prompt = this.buildAIPrompt(analysisData);

    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openRouterApiKey}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://trueroof.com.au',
        'X-Title': 'TrueRoof Optimization AI'
      },
      body: JSON.stringify({
        model: 'anthropic/claude-3.5-sonnet',
        messages: [
          {
            role: 'system',
            content: `You are a senior frontend optimization expert analyzing user behavior data to improve website conversion rates. Focus on practical, implementable changes with clear business impact.`
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.7,
        max_tokens: 4000
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`AI service error: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    const aiContent = result.choices[0]?.message?.content;
    
    if (!aiContent) {
      throw new Error('No content in AI response');
    }

    // Parse AI response
    return this.parseAIResponse(aiContent);
  },

  buildAIPrompt(analysisData) {
    return `Analyze this user behavior data and generate specific optimization proposals:

FRICTION POINTS (${analysisData.friction_points.length} total):
${analysisData.friction_points.map(fp => `
- Element: ${fp.element_path} (${fp.element_type})
- Event: ${fp.event_type}
- Frequency: ${fp.event_count} events across ${fp.affected_sessions} sessions
- Pages: ${fp.pages_affected?.slice(0, 3).join(', ')}...
`).join('')}

COMPONENT PERFORMANCE (top 5 by rage clicks):
${analysisData.component_performance.slice(0, 5).map(cp => `
- Component: ${cp.component_id}
- Page: ${cp.page_url}
- Rage Clicks: ${cp.rage_clicks}
- Hesitations: ${cp.hesitations}
- Avg Hesitation: ${cp.avg_hesitation_ms}ms
- Conversions: ${cp.conversions}
`).join('')}

GENERATE OPTIMIZATION PROPOSALS WITH THIS FORMAT:

For each proposal, provide:
1. FRICTION_POINT: Brief description of the problem
2. COMPONENT_ID: Target component (if applicable)
3. PAGE_URL: Target page
4. CHANGE_DESCRIPTION: Clear description of the proposed change
5. PROPOSED_CHANGES: JSON object with specific changes:
   - css_changes: Array of CSS rules to add/modify
   - html_changes: Array of HTML structure changes
   - js_changes: Array of JavaScript behavior changes
   - a11y_changes: Array of accessibility improvements
6. EXPECTED_IMPACT: Estimated conversion impact (0.0-1.0)
7. AI_CONFIDENCE: Your confidence in this proposal (0.0-1.0)
8. TESTING_STRATEGY: How to A/B test this change

Return your response as a JSON array of proposals. Focus on:
- Reducing rage clicks and hesitations
- Improving form completion rates
- Enhancing mobile experience
- Fixing accessibility issues
- Simplifying complex interactions

Be specific and actionable. Prioritize high-impact, low-effort changes first.`;
  },

  parseAIResponse(aiContent) {
    try {
      // Extract JSON from AI response (handles markdown code blocks)
      const jsonMatch = aiContent.match(/```json\n([\s\S]*?)\n```/) || 
                       aiContent.match(/```\n([\s\S]*?)\n```/) ||
                       aiContent.match(/\[[\s\S]*\]/);
      
      if (!jsonMatch) {
        throw new Error('No JSON found in AI response');
      }

      const jsonStr = jsonMatch[1] || jsonMatch[0];
      const proposals = JSON.parse(jsonStr);

      // Validate proposal structure
      const validProposals = proposals.filter(proposal => 
        proposal.friction_point &&
        proposal.change_description &&
        proposal.proposed_changes &&
        proposal.expected_impact != null &&
        proposal.ai_confidence != null
      );

      // Add metadata
      return {
        optimizations: validProposals.map(proposal => ({
          ...proposal,
          proposal_id: `opt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          created_at: new Date().toISOString(),
          status: 'proposed'
        })),
        total_proposals: validProposals.length,
        analysis_timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Failed to parse AI response:', error, 'Content:', aiContent.substring(0, 500));
      throw new Error(`Failed to parse AI response: ${error.message}`);
    }
  },

  async validateProposals(proposals, supabase) {
    const validationRules = {
      max_css_rules: 10,
      max_html_changes: 5,
      allowed_file_types: ['.tsx', '.ts', '.jsx', '.js', '.css', '.scss'],
      disallowed_selectors: ['body', 'html', '*', 'script', 'style'],
      min_confidence: 0.6,
      max_impact: 1.0
    };

    const validProposals = [];

    for (const proposal of proposals) {
      try {
        // Basic validation
        if (proposal.ai_confidence < validationRules.min_confidence) {
          console.log(`Skipping proposal ${proposal.proposal_id}: confidence too low`);
          continue;
        }

        if (proposal.expected_impact > validationRules.max_impact) {
          console.log(`Skipping proposal ${proposal.proposal_id}: impact estimate too high`);
          continue;
        }

        // Validate CSS changes
        if (proposal.proposed_changes.css_changes) {
          if (proposal.proposed_changes.css_changes.length > validationRules.max_css_rules) {
            console.log(`Skipping proposal ${proposal.proposal_id}: too many CSS changes`);
            continue;
          }

          // Check for dangerous selectors
          const dangerousSelectors = proposal.proposed_changes.css_changes
            .filter(rule => validationRules.disallowed_selectors.some(
              selector => rule.selector?.includes(selector)
            ));
          
          if (dangerousSelectors.length > 0) {
            console.log(`Skipping proposal ${proposal.proposal_id}: contains dangerous CSS selectors`);
            continue;
          }
        }

        // Check if similar proposal already exists
        const { data: existingProposals } = await supabase
          .from('optimization_history')
          .select('proposal_id, status')
          .eq('component_id', proposal.component_id)
          .eq('friction_point', proposal.friction_point)
          .in('status', ['proposed', 'approved', 'implemented', 'testing'])
          .limit(1);

        if (existingProposals && existingProposals.length > 0) {
          console.log(`Skipping proposal ${proposal.proposal_id}: similar proposal already exists`);
          continue;
        }

        validProposals.push(proposal);

      } catch (error) {
        console.error(`Error validating proposal ${proposal.proposal_id}:`, error);
      }
    }

    return validProposals;
  },

  async createGitHubPR(env, proposal) {
    const githubToken = env.GITHUB_TOKEN;
    const repo = env.GITHUB_REPO || 'getwebface/true-roof-2026';
    
    if (!githubToken) {
      throw new Error('GitHub token not configured');
    }

    // Generate branch name
    const branchName = `optimization/${proposal.proposal_id}`.replace(/[^a-zA-Z0-9-_]/g, '-');
    
    // Create commit message
    const commitMessage = `Optimization: ${proposal.friction_point}\n\n${proposal.change_description}\n\nProposal ID: ${proposal.proposal_id}`;

    // Create PR description
    const prDescription = `## Optimization Proposal: ${proposal.friction_point}

**Target Component:** ${proposal.component_id || 'N/A'}
**Target Page:** ${proposal.page_url || 'Multiple pages'}

### Problem Identified
${proposal.friction_point}

### Proposed Solution
${proposal.change_description}

### Expected Impact
- **Confidence:** ${(proposal.ai_confidence * 100).toFixed(1)}%
- **Expected Conversion Improvement:** ${(proposal.expected_impact * 100).toFixed(1)}%

### Changes
${this.formatChangesForPR(proposal.proposed_changes)}

### Testing Strategy
${proposal.testing_strategy || 'A/B test with 50/50 split for 7 days'}

**Proposal ID:** ${proposal.proposal_id}
**Generated:** ${new Date().toISOString()}

---

*This PR was automatically generated by the AI Optimization System.*`;

    try {
      // Note: In a real implementation, we would:
      // 1. Create a new branch
      // 2. Make the proposed changes to files
      // 3. Create a commit
      // 4. Create a PR
      
      // For now, we'll create a simplified version that creates an issue
      // The actual file changes would be handled by a separate script
      
      const response = await fetch(`https://api.github.com/repos/${repo}/pulls`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          title: `Optimization: ${proposal.friction_point.substring(0, 100)}`,
          body: prDescription,
          head: branchName,
          base: 'main',
          draft: true, // Create as draft for human review
          maintainer_can_modify: true
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`GitHub API error: ${response.status} - ${errorText}`);
      }

      const prData = await response.json();
      
      return {
        success: true,
        proposal_id: proposal.proposal_id,
        pr_url: prData.html_url,
        pr_number: prData.number,
        branch_name: branchName
      };

    } catch (error) {
      console.error(`Failed to create GitHub PR for ${proposal.proposal_id}:`, error);
      return {
        success: false,
        proposal_id: proposal.proposal_id,
        error: error.message
      };
    }
  },

  formatChangesForPR(changes) {
    let formatted = '';

    if (changes.css_changes && changes.css_changes.length > 0) {
      formatted += '#### CSS Changes\n```css\n';
      changes.css_changes.forEach(rule => {
        formatted += `${rule.selector} {\n`;
        Object.entries(rule.properties || {}).forEach(([prop, value]) => {
          formatted += `  ${prop}: ${value};\n`;
        });
        formatted += '}\n\n';
      });
      formatted += '```\n';
    }

    if (changes.html_changes && changes.html_changes.length > 0) {
      formatted += '#### HTML Changes\n```html\n';
      changes.html_changes.forEach(change => {
        formatted += `${change.description}\n`;
        if (change.before) formatted += `Before: ${change.before}\n`;
        if (change.after) formatted += `After: ${change.after}\n`;
        formatted += '\n';
      });
      formatted += '```\n';
    }

    if (changes.js_changes && changes.js_changes.length > 0) {
      formatted += '#### JavaScript Changes\n```javascript\n';
      changes.js_changes.forEach(change => {
        formatted += `${change.description}\n`;
        if (change.code) formatted += `${change.code}\n\n`;
      });
      formatted += '```\n';
    }

    if (changes.a11y_changes && changes.a11y_changes.length > 0) {
      formatted += '#### Accessibility Improvements\n';
      changes.a11y_changes.forEach(change => {
        formatted += `- ${change}\n`;
      });
    }

    return formatted || 'No specific changes detailed.';
  },

  async recordOptimizationHistory(supabase, proposals, results) {
    const historyEntries = proposals.map((proposal, index) => {
      const result = results[index];
      const prResult = result.status === 'fulfilled' ? result.value : null;

      return {
        proposal_id: proposal.proposal_id,
        status: prResult?.success ? 'proposed' : 'rejected',
        friction_point: proposal.friction_point,
        component_id: proposal.component_id,
        page_url: proposal.page_url,
        change_description: proposal.change_description,
        proposed_changes: proposal.proposed_changes,
        ai_confidence: proposal.ai_confidence,
        expected_impact: proposal.expected_impact,
        pr_url: prResult?.pr_url || null,
        pr_number: prResult?.pr_number || null,
        created_at: proposal.created_at,
        metadata: {
          validation_result: prResult?.success ? 'passed' : 'failed',
          error: prResult?.error || null,
          branch_name: prResult?.branch_name || null
        }
      };
    });

    if (historyEntries.length > 0) {
      const { error } = await supabase
        .from('optimization_history')
        .insert(historyEntries);

      if (error) {
        console.error('Failed to record optimization history:', error);
      }
    }
  }
};
